// Code generated by protoc-gen-zig
///! package steam
const std = @import("std");

const protobuf = @import("protobuf");
const fd = protobuf.fd;

pub const CMsgSteamNetworkingIdentityLegacyBinary = struct {
    steam_id: ?u64 = null,
    generic_bytes: ?[]const u8 = null,
    generic_string: ?[]const u8 = null,
    ipv6_and_port: ?[]const u8 = null,

    pub const _desc_table = .{
        .steam_id = fd(16, .{ .scalar = .fixed64 }),
        .generic_bytes = fd(2, .{ .scalar = .bytes }),
        .generic_string = fd(3, .{ .scalar = .string }),
        .ipv6_and_port = fd(4, .{ .scalar = .bytes }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramCertificate = struct {
    key_type: ?CMsgSteamDatagramCertificate.EKeyType = .INVALID,
    key_data: ?[]const u8 = null,
    legacy_steam_id: ?u64 = null,
    legacy_identity_binary: ?CMsgSteamNetworkingIdentityLegacyBinary = null,
    identity_string: ?[]const u8 = null,
    gameserver_datacenter_ids: std.ArrayListUnmanaged(u32) = .empty,
    time_created: ?u32 = null,
    time_expiry: ?u32 = null,
    app_ids: std.ArrayListUnmanaged(u32) = .empty,
    ip_addresses: std.ArrayListUnmanaged([]const u8) = .empty,

    pub const _desc_table = .{
        .key_type = fd(1, .@"enum"),
        .key_data = fd(2, .{ .scalar = .bytes }),
        .legacy_steam_id = fd(4, .{ .scalar = .fixed64 }),
        .legacy_identity_binary = fd(11, .submessage),
        .identity_string = fd(12, .{ .scalar = .string }),
        .gameserver_datacenter_ids = fd(5, .{ .repeated = .{ .scalar = .fixed32 } }),
        .time_created = fd(8, .{ .scalar = .fixed32 }),
        .time_expiry = fd(9, .{ .scalar = .fixed32 }),
        .app_ids = fd(10, .{ .repeated = .{ .scalar = .uint32 } }),
        .ip_addresses = fd(13, .{ .repeated = .{ .scalar = .string } }),
    };

    pub const EKeyType = enum(i32) {
        INVALID = 0,
        ED25519 = 1,
        _,
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramCertificateSigned = struct {
    cert: ?[]const u8 = null,
    ca_key_id: ?u64 = null,
    ca_signature: ?[]const u8 = null,
    private_key_data: ?[]const u8 = null,

    pub const _desc_table = .{
        .cert = fd(4, .{ .scalar = .bytes }),
        .ca_key_id = fd(5, .{ .scalar = .fixed64 }),
        .ca_signature = fd(6, .{ .scalar = .bytes }),
        .private_key_data = fd(1, .{ .scalar = .bytes }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramCertificateRequest = struct {
    cert: ?CMsgSteamDatagramCertificate = null,

    pub const _desc_table = .{
        .cert = fd(1, .submessage),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramRelayAuthTicket = struct {
    time_expiry: ?u32 = null,
    authorized_client_identity_string: ?[]const u8 = null,
    gameserver_identity_string: ?[]const u8 = null,
    authorized_public_ip: ?u32 = null,
    gameserver_address: ?[]const u8 = null,
    app_id: ?u32 = null,
    virtual_port: ?u32 = null,
    extra_fields: std.ArrayListUnmanaged(CMsgSteamDatagramRelayAuthTicket.ExtraField) = .empty,
    legacy_authorized_steam_id: ?u64 = null,
    legacy_gameserver_steam_id: ?u64 = null,
    legacy_gameserver_pop_id: ?u32 = null,
    legacy_authorized_client_identity_binary: ?[]const u8 = null,
    legacy_gameserver_identity_binary: ?[]const u8 = null,

    pub const _desc_table = .{
        .time_expiry = fd(1, .{ .scalar = .fixed32 }),
        .authorized_client_identity_string = fd(14, .{ .scalar = .string }),
        .gameserver_identity_string = fd(15, .{ .scalar = .string }),
        .authorized_public_ip = fd(3, .{ .scalar = .fixed32 }),
        .gameserver_address = fd(11, .{ .scalar = .bytes }),
        .app_id = fd(7, .{ .scalar = .uint32 }),
        .virtual_port = fd(10, .{ .scalar = .uint32 }),
        .extra_fields = fd(8, .{ .repeated = .submessage }),
        .legacy_authorized_steam_id = fd(2, .{ .scalar = .fixed64 }),
        .legacy_gameserver_steam_id = fd(4, .{ .scalar = .fixed64 }),
        .legacy_gameserver_pop_id = fd(9, .{ .scalar = .fixed32 }),
        .legacy_authorized_client_identity_binary = fd(12, .{ .scalar = .bytes }),
        .legacy_gameserver_identity_binary = fd(13, .{ .scalar = .bytes }),
    };

    pub const ExtraField = struct {
        name: ?[]const u8 = null,
        string_value: ?[]const u8 = null,
        int64_value: ?i64 = null,
        fixed64_value: ?u64 = null,

        pub const _desc_table = .{
            .name = fd(1, .{ .scalar = .string }),
            .string_value = fd(2, .{ .scalar = .string }),
            .int64_value = fd(3, .{ .scalar = .sint64 }),
            .fixed64_value = fd(5, .{ .scalar = .fixed64 }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramSignedRelayAuthTicket = struct {
    reserved_do_not_use: ?u64 = null,
    ticket: ?[]const u8 = null,
    signature: ?[]const u8 = null,
    key_id: ?u64 = null,
    certs: std.ArrayListUnmanaged(CMsgSteamDatagramCertificateSigned) = .empty,

    pub const _desc_table = .{
        .reserved_do_not_use = fd(1, .{ .scalar = .fixed64 }),
        .ticket = fd(3, .{ .scalar = .bytes }),
        .signature = fd(4, .{ .scalar = .bytes }),
        .key_id = fd(2, .{ .scalar = .fixed64 }),
        .certs = fd(5, .{ .repeated = .submessage }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramCachedCredentialsForApp = struct {
    private_key: ?[]const u8 = null,
    cert: ?[]const u8 = null,
    relay_tickets: std.ArrayListUnmanaged([]const u8) = .empty,

    pub const _desc_table = .{
        .private_key = fd(1, .{ .scalar = .bytes }),
        .cert = fd(2, .{ .scalar = .bytes }),
        .relay_tickets = fd(3, .{ .repeated = .{ .scalar = .bytes } }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramGameCoordinatorServerLogin = struct {
    time_generated: ?u32 = null,
    appid: ?u32 = null,
    routing: ?[]const u8 = null,
    appdata: ?[]const u8 = null,
    legacy_identity_binary: ?[]const u8 = null,
    identity_string: ?[]const u8 = null,
    dummy_steam_id: ?u64 = null,

    pub const _desc_table = .{
        .time_generated = fd(1, .{ .scalar = .uint32 }),
        .appid = fd(2, .{ .scalar = .uint32 }),
        .routing = fd(3, .{ .scalar = .bytes }),
        .appdata = fd(4, .{ .scalar = .bytes }),
        .legacy_identity_binary = fd(5, .{ .scalar = .bytes }),
        .identity_string = fd(6, .{ .scalar = .string }),
        .dummy_steam_id = fd(99, .{ .scalar = .fixed64 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramSignedGameCoordinatorServerLogin = struct {
    cert: ?CMsgSteamDatagramCertificateSigned = null,
    login: ?[]const u8 = null,
    signature: ?[]const u8 = null,

    pub const _desc_table = .{
        .cert = fd(1, .submessage),
        .login = fd(2, .{ .scalar = .bytes }),
        .signature = fd(3, .{ .scalar = .bytes }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramHostedServerAddressPlaintext = struct {
    ipv4: ?u32 = null,
    ipv6: ?[]const u8 = null,
    port: ?u32 = null,
    routing_secret: ?u64 = null,
    protocol_version: ?u32 = null,

    pub const _desc_table = .{
        .ipv4 = fd(1, .{ .scalar = .fixed32 }),
        .ipv6 = fd(2, .{ .scalar = .bytes }),
        .port = fd(3, .{ .scalar = .uint32 }),
        .routing_secret = fd(4, .{ .scalar = .fixed64 }),
        .protocol_version = fd(5, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const ESteamNetworkingSocketsCipher = enum(i32) {
    k_ESteamNetworkingSocketsCipher_INVALID = 0,
    k_ESteamNetworkingSocketsCipher_NULL = 1,
    k_ESteamNetworkingSocketsCipher_AES_256_GCM = 2,
    _,
};

pub const CMsgSteamDatagramSessionCryptInfo = struct {
    key_type: ?CMsgSteamDatagramSessionCryptInfo.EKeyType = .INVALID,
    key_data: ?[]const u8 = null,
    nonce: ?u64 = null,
    protocol_version: ?u32 = null,
    ciphers: std.ArrayListUnmanaged(ESteamNetworkingSocketsCipher) = .empty,

    pub const _desc_table = .{
        .key_type = fd(1, .@"enum"),
        .key_data = fd(2, .{ .scalar = .bytes }),
        .nonce = fd(3, .{ .scalar = .fixed64 }),
        .protocol_version = fd(4, .{ .scalar = .uint32 }),
        .ciphers = fd(5, .{ .repeated = .@"enum" }),
    };

    pub const EKeyType = enum(i32) {
        INVALID = 0,
        CURVE25519 = 1,
        _,
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramSessionCryptInfoSigned = struct {
    info: ?[]const u8 = null,
    signature: ?[]const u8 = null,

    pub const _desc_table = .{
        .info = fd(1, .{ .scalar = .bytes }),
        .signature = fd(2, .{ .scalar = .bytes }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramDiagnostic = struct {
    severity: ?u32 = null,
    text: ?[]const u8 = null,

    pub const _desc_table = .{
        .severity = fd(1, .{ .scalar = .uint32 }),
        .text = fd(2, .{ .scalar = .string }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramLinkInstantaneousStats = struct {
    out_packets_per_sec_x10: ?u32 = null,
    out_bytes_per_sec: ?u32 = null,
    in_packets_per_sec_x10: ?u32 = null,
    in_bytes_per_sec: ?u32 = null,
    ping_ms: ?u32 = null,
    packets_dropped_pct: ?u32 = null,
    packets_weird_sequence_pct: ?u32 = null,
    peak_jitter_usec: ?u32 = null,

    pub const _desc_table = .{
        .out_packets_per_sec_x10 = fd(1, .{ .scalar = .uint32 }),
        .out_bytes_per_sec = fd(2, .{ .scalar = .uint32 }),
        .in_packets_per_sec_x10 = fd(3, .{ .scalar = .uint32 }),
        .in_bytes_per_sec = fd(4, .{ .scalar = .uint32 }),
        .ping_ms = fd(5, .{ .scalar = .uint32 }),
        .packets_dropped_pct = fd(6, .{ .scalar = .uint32 }),
        .packets_weird_sequence_pct = fd(7, .{ .scalar = .uint32 }),
        .peak_jitter_usec = fd(8, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramLinkLifetimeStats = struct {
    connected_seconds: ?u32 = null,
    packets_sent: ?u64 = null,
    kb_sent: ?u64 = null,
    packets_recv: ?u64 = null,
    kb_recv: ?u64 = null,
    packets_recv_sequenced: ?u64 = null,
    packets_recv_dropped: ?u64 = null,
    packets_recv_out_of_order: ?u64 = null,
    packets_recv_out_of_order_corrected: ?u64 = null,
    packets_recv_duplicate: ?u64 = null,
    packets_recv_lurch: ?u64 = null,
    multipath_packets_recv_sequenced: std.ArrayListUnmanaged(u64) = .empty,
    multipath_packets_recv_later: std.ArrayListUnmanaged(u64) = .empty,
    multipath_send_enabled: ?u32 = null,
    quality_histogram_100: ?u32 = null,
    quality_histogram_99: ?u32 = null,
    quality_histogram_97: ?u32 = null,
    quality_histogram_95: ?u32 = null,
    quality_histogram_90: ?u32 = null,
    quality_histogram_75: ?u32 = null,
    quality_histogram_50: ?u32 = null,
    quality_histogram_1: ?u32 = null,
    quality_histogram_dead: ?u32 = null,
    quality_ntile_2nd: ?u32 = null,
    quality_ntile_5th: ?u32 = null,
    quality_ntile_25th: ?u32 = null,
    quality_ntile_50th: ?u32 = null,
    ping_histogram_25: ?u32 = null,
    ping_histogram_50: ?u32 = null,
    ping_histogram_75: ?u32 = null,
    ping_histogram_100: ?u32 = null,
    ping_histogram_125: ?u32 = null,
    ping_histogram_150: ?u32 = null,
    ping_histogram_200: ?u32 = null,
    ping_histogram_300: ?u32 = null,
    ping_histogram_max: ?u32 = null,
    ping_ntile_5th: ?u32 = null,
    ping_ntile_50th: ?u32 = null,
    ping_ntile_75th: ?u32 = null,
    ping_ntile_95th: ?u32 = null,
    ping_ntile_98th: ?u32 = null,
    jitter_histogram_negligible: ?u32 = null,
    jitter_histogram_1: ?u32 = null,
    jitter_histogram_2: ?u32 = null,
    jitter_histogram_5: ?u32 = null,
    jitter_histogram_10: ?u32 = null,
    jitter_histogram_20: ?u32 = null,

    pub const _desc_table = .{
        .connected_seconds = fd(2, .{ .scalar = .uint32 }),
        .packets_sent = fd(3, .{ .scalar = .uint64 }),
        .kb_sent = fd(4, .{ .scalar = .uint64 }),
        .packets_recv = fd(5, .{ .scalar = .uint64 }),
        .kb_recv = fd(6, .{ .scalar = .uint64 }),
        .packets_recv_sequenced = fd(7, .{ .scalar = .uint64 }),
        .packets_recv_dropped = fd(8, .{ .scalar = .uint64 }),
        .packets_recv_out_of_order = fd(9, .{ .scalar = .uint64 }),
        .packets_recv_out_of_order_corrected = fd(15, .{ .scalar = .uint64 }),
        .packets_recv_duplicate = fd(10, .{ .scalar = .uint64 }),
        .packets_recv_lurch = fd(11, .{ .scalar = .uint64 }),
        .multipath_packets_recv_sequenced = fd(12, .{ .repeated = .{ .scalar = .uint64 } }),
        .multipath_packets_recv_later = fd(13, .{ .repeated = .{ .scalar = .uint64 } }),
        .multipath_send_enabled = fd(14, .{ .scalar = .uint32 }),
        .quality_histogram_100 = fd(21, .{ .scalar = .uint32 }),
        .quality_histogram_99 = fd(22, .{ .scalar = .uint32 }),
        .quality_histogram_97 = fd(23, .{ .scalar = .uint32 }),
        .quality_histogram_95 = fd(24, .{ .scalar = .uint32 }),
        .quality_histogram_90 = fd(25, .{ .scalar = .uint32 }),
        .quality_histogram_75 = fd(26, .{ .scalar = .uint32 }),
        .quality_histogram_50 = fd(27, .{ .scalar = .uint32 }),
        .quality_histogram_1 = fd(28, .{ .scalar = .uint32 }),
        .quality_histogram_dead = fd(29, .{ .scalar = .uint32 }),
        .quality_ntile_2nd = fd(30, .{ .scalar = .uint32 }),
        .quality_ntile_5th = fd(31, .{ .scalar = .uint32 }),
        .quality_ntile_25th = fd(32, .{ .scalar = .uint32 }),
        .quality_ntile_50th = fd(33, .{ .scalar = .uint32 }),
        .ping_histogram_25 = fd(41, .{ .scalar = .uint32 }),
        .ping_histogram_50 = fd(42, .{ .scalar = .uint32 }),
        .ping_histogram_75 = fd(43, .{ .scalar = .uint32 }),
        .ping_histogram_100 = fd(44, .{ .scalar = .uint32 }),
        .ping_histogram_125 = fd(45, .{ .scalar = .uint32 }),
        .ping_histogram_150 = fd(46, .{ .scalar = .uint32 }),
        .ping_histogram_200 = fd(47, .{ .scalar = .uint32 }),
        .ping_histogram_300 = fd(48, .{ .scalar = .uint32 }),
        .ping_histogram_max = fd(49, .{ .scalar = .uint32 }),
        .ping_ntile_5th = fd(50, .{ .scalar = .uint32 }),
        .ping_ntile_50th = fd(51, .{ .scalar = .uint32 }),
        .ping_ntile_75th = fd(52, .{ .scalar = .uint32 }),
        .ping_ntile_95th = fd(53, .{ .scalar = .uint32 }),
        .ping_ntile_98th = fd(54, .{ .scalar = .uint32 }),
        .jitter_histogram_negligible = fd(61, .{ .scalar = .uint32 }),
        .jitter_histogram_1 = fd(62, .{ .scalar = .uint32 }),
        .jitter_histogram_2 = fd(63, .{ .scalar = .uint32 }),
        .jitter_histogram_5 = fd(64, .{ .scalar = .uint32 }),
        .jitter_histogram_10 = fd(65, .{ .scalar = .uint32 }),
        .jitter_histogram_20 = fd(66, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramConnectionQuality = struct {
    instantaneous: ?CMsgSteamDatagramLinkInstantaneousStats = null,
    lifetime: ?CMsgSteamDatagramLinkLifetimeStats = null,

    pub const _desc_table = .{
        .instantaneous = fd(1, .submessage),
        .lifetime = fd(2, .submessage),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgICECandidate = struct {
    candidate: ?[]const u8 = null,

    pub const _desc_table = .{
        .candidate = fd(3, .{ .scalar = .string }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgICERendezvous = struct {
    auth: ?CMsgICERendezvous.Auth = null,
    add_candidate: ?CMsgICECandidate = null,

    pub const _desc_table = .{
        .auth = fd(2, .submessage),
        .add_candidate = fd(1, .submessage),
    };

    pub const Auth = struct {
        pwd_frag: ?[]const u8 = null,

        pub const _desc_table = .{
            .pwd_frag = fd(1, .{ .scalar = .string }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamNetworkingP2PRendezvous = struct {
    from_identity: ?[]const u8 = null,
    from_connection_id: ?u32 = null,
    to_identity: ?[]const u8 = null,
    to_connection_id: ?u32 = null,
    sdr_routes: ?[]const u8 = null,
    ack_peer_routes_revision: ?u32 = null,
    ice_enabled: ?bool = null,
    hosted_server_ticket: ?[]const u8 = null,
    connect_request: ?CMsgSteamNetworkingP2PRendezvous.ConnectRequest = null,
    connect_ok: ?CMsgSteamNetworkingP2PRendezvous.ConnectOK = null,
    connection_closed: ?CMsgSteamNetworkingP2PRendezvous.ConnectionClosed = null,
    ack_reliable_msg: ?u32 = null,
    first_reliable_msg: ?u32 = null,
    reliable_messages: std.ArrayListUnmanaged(CMsgSteamNetworkingP2PRendezvous.ReliableMessage) = .empty,
    application_messages: std.ArrayListUnmanaged(CMsgSteamNetworkingP2PRendezvous.ApplicationMessage) = .empty,

    pub const _desc_table = .{
        .from_identity = fd(8, .{ .scalar = .string }),
        .from_connection_id = fd(9, .{ .scalar = .fixed32 }),
        .to_identity = fd(10, .{ .scalar = .string }),
        .to_connection_id = fd(1, .{ .scalar = .fixed32 }),
        .sdr_routes = fd(2, .{ .scalar = .bytes }),
        .ack_peer_routes_revision = fd(3, .{ .scalar = .uint32 }),
        .ice_enabled = fd(7, .{ .scalar = .bool }),
        .hosted_server_ticket = fd(14, .{ .scalar = .bytes }),
        .connect_request = fd(4, .submessage),
        .connect_ok = fd(5, .submessage),
        .connection_closed = fd(6, .submessage),
        .ack_reliable_msg = fd(11, .{ .scalar = .uint32 }),
        .first_reliable_msg = fd(12, .{ .scalar = .uint32 }),
        .reliable_messages = fd(13, .{ .repeated = .submessage }),
        .application_messages = fd(15, .{ .repeated = .submessage }),
    };

    pub const ConnectRequest = struct {
        crypt: ?CMsgSteamDatagramSessionCryptInfoSigned = null,
        cert: ?CMsgSteamDatagramCertificateSigned = null,
        to_virtual_port: ?u32 = null,
        from_virtual_port: ?u32 = null,
        from_fakeip: ?[]const u8 = null,

        pub const _desc_table = .{
            .crypt = fd(6, .submessage),
            .cert = fd(7, .submessage),
            .to_virtual_port = fd(9, .{ .scalar = .uint32 }),
            .from_virtual_port = fd(10, .{ .scalar = .uint32 }),
            .from_fakeip = fd(11, .{ .scalar = .string }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const ConnectOK = struct {
        crypt: ?CMsgSteamDatagramSessionCryptInfoSigned = null,
        cert: ?CMsgSteamDatagramCertificateSigned = null,

        pub const _desc_table = .{
            .crypt = fd(5, .submessage),
            .cert = fd(6, .submessage),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const ConnectionClosed = struct {
        debug: ?[]const u8 = null,
        reason_code: ?u32 = null,

        pub const _desc_table = .{
            .debug = fd(5, .{ .scalar = .string }),
            .reason_code = fd(6, .{ .scalar = .uint32 }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const ReliableMessage = struct {
        ice: ?CMsgICERendezvous = null,

        pub const _desc_table = .{
            .ice = fd(1, .submessage),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const ApplicationMessage = struct {
        data: ?[]const u8 = null,
        msg_num: ?u64 = null,
        flags: ?u32 = null,
        lane_idx: ?u32 = null,

        pub const _desc_table = .{
            .data = fd(1, .{ .scalar = .bytes }),
            .msg_num = fd(2, .{ .scalar = .uint64 }),
            .flags = fd(3, .{ .scalar = .uint32 }),
            .lane_idx = fd(4, .{ .scalar = .uint32 }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamNetworkingICESessionSummary = struct {
    failure_reason_code: ?u32 = null,
    local_candidate_types: ?u32 = null,
    remote_candidate_types: ?u32 = null,
    initial_route_kind: ?u32 = null,
    initial_ping: ?u32 = null,
    initial_score: ?u32 = null,
    negotiation_ms: ?u32 = null,
    best_route_kind: ?u32 = null,
    best_ping: ?u32 = null,
    best_score: ?u32 = null,
    best_time: ?u32 = null,
    selected_seconds: ?u32 = null,
    user_settings: ?u32 = null,
    ice_enable_var: ?u32 = null,
    local_candidate_types_allowed: ?u32 = null,

    pub const _desc_table = .{
        .failure_reason_code = fd(7, .{ .scalar = .uint32 }),
        .local_candidate_types = fd(1, .{ .scalar = .uint32 }),
        .remote_candidate_types = fd(2, .{ .scalar = .uint32 }),
        .initial_route_kind = fd(3, .{ .scalar = .uint32 }),
        .initial_ping = fd(4, .{ .scalar = .uint32 }),
        .initial_score = fd(6, .{ .scalar = .uint32 }),
        .negotiation_ms = fd(5, .{ .scalar = .uint32 }),
        .best_route_kind = fd(16, .{ .scalar = .uint32 }),
        .best_ping = fd(17, .{ .scalar = .uint32 }),
        .best_score = fd(18, .{ .scalar = .uint32 }),
        .best_time = fd(19, .{ .scalar = .uint32 }),
        .selected_seconds = fd(12, .{ .scalar = .uint32 }),
        .user_settings = fd(13, .{ .scalar = .uint32 }),
        .ice_enable_var = fd(14, .{ .scalar = .uint32 }),
        .local_candidate_types_allowed = fd(15, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const ESteamDatagramMsgID = enum(i32) {
    k_ESteamDatagramMsg_Invalid = 0,
    k_ESteamDatagramMsg_RouterPingRequest = 1,
    k_ESteamDatagramMsg_RouterPingReply = 2,
    k_ESteamDatagramMsg_GameserverPingRequest = 3,
    k_ESteamDatagramMsg_GameserverSessionRequest = 5,
    k_ESteamDatagramMsg_GameserverSessionEstablished = 6,
    k_ESteamDatagramMsg_NoSession = 7,
    k_ESteamDatagramMsg_Diagnostic = 8,
    k_ESteamDatagramMsg_DataClientToRouter = 9,
    k_ESteamDatagramMsg_DataRouterToServer = 10,
    k_ESteamDatagramMsg_DataServerToRouter = 11,
    k_ESteamDatagramMsg_DataRouterToClient = 12,
    k_ESteamDatagramMsg_Stats = 13,
    k_ESteamDatagramMsg_ClientPingSampleRequest = 14,
    k_ESteamDatagramMsg_ClientPingSampleReply = 15,
    k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary = 16,
    k_ESteamDatagramMsg_RelayHealth = 17,
    k_ESteamDatagramMsg_ConnectRequest = 18,
    k_ESteamDatagramMsg_ConnectOK = 19,
    k_ESteamDatagramMsg_ConnectionClosed = 20,
    k_ESteamDatagramMsg_NoConnection = 21,
    k_ESteamDatagramMsg_TicketDecryptRequest = 22,
    k_ESteamDatagramMsg_TicketDecryptReply = 23,
    k_ESteamDatagramMsg_P2PSessionRequest = 24,
    k_ESteamDatagramMsg_P2PSessionEstablished = 25,
    k_ESteamDatagramMsg_P2PStatsClient = 26,
    k_ESteamDatagramMsg_P2PStatsRelay = 27,
    k_ESteamDatagramMsg_P2PBadRoute = 28,
    k_ESteamDatagramMsg_GameserverPingReply = 29,
    k_ESteamDatagramMsg_LegacyGameserverRegistration = 30,
    k_ESteamDatagramMsg_SetSecondaryAddressRequest = 31,
    k_ESteamDatagramMsg_SetSecondaryAddressResult = 32,
    k_ESteamDatagramMsg_RelayToRelayPingRequest = 33,
    k_ESteamDatagramMsg_RelayToRelayPingReply = 34,
    _,
};

pub const CMsgSteamNetworkingIPAddress = struct {
    v4: ?u32 = null,
    v6: ?[]const u8 = null,

    pub const _desc_table = .{
        .v4 = fd(1, .{ .scalar = .fixed32 }),
        .v6 = fd(2, .{ .scalar = .bytes }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramSignedMessageGeneric = struct {
    cert: ?CMsgSteamDatagramCertificateSigned = null,
    signed_data: ?[]const u8 = null,
    signature: ?[]const u8 = null,
    dummy_pad: ?[]const u8 = null,

    pub const _desc_table = .{
        .cert = fd(1, .submessage),
        .signed_data = fd(2, .{ .scalar = .bytes }),
        .signature = fd(3, .{ .scalar = .bytes }),
        .dummy_pad = fd(1023, .{ .scalar = .bytes }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramRouterPingReply = struct {
    client_timestamp: ?u32 = null,
    latency_datacenter_ids: std.ArrayListUnmanaged(u32) = .empty,
    latency_ping_ms: std.ArrayListUnmanaged(u32) = .empty,
    latency_datacenter_ids_p2p: std.ArrayListUnmanaged(u32) = .empty,
    latency_ping_ms_p2p: std.ArrayListUnmanaged(u32) = .empty,
    your_public_ip: ?u32 = null,
    your_public_port: ?u32 = null,
    server_time: ?u32 = null,
    challenge: ?u64 = null,
    seconds_until_shutdown: ?u32 = null,
    client_cookie: ?u32 = null,
    recv_tos: ?u32 = null,
    echo_sent_tos: ?u32 = null,
    sent_tos: ?u32 = null,
    echo_request_reply_tos: ?u32 = null,
    scoring_penalty_relay_cluster: ?u32 = null,
    flags: ?u32 = null,
    route_exceptions: std.ArrayListUnmanaged(CMsgSteamDatagramRouterPingReply.RouteException) = .empty,
    alt_addresses: std.ArrayListUnmanaged(CMsgSteamDatagramRouterPingReply.AltAddress) = .empty,
    dummy_pad: ?[]const u8 = null,
    dummy_varint: ?u64 = null,

    pub const _desc_table = .{
        .client_timestamp = fd(1, .{ .scalar = .fixed32 }),
        .latency_datacenter_ids = fd(2, .{ .packed_repeated = .{ .scalar = .fixed32 } }),
        .latency_ping_ms = fd(3, .{ .packed_repeated = .{ .scalar = .uint32 } }),
        .latency_datacenter_ids_p2p = fd(14, .{ .packed_repeated = .{ .scalar = .fixed32 } }),
        .latency_ping_ms_p2p = fd(15, .{ .packed_repeated = .{ .scalar = .uint32 } }),
        .your_public_ip = fd(4, .{ .scalar = .fixed32 }),
        .your_public_port = fd(11, .{ .scalar = .fixed32 }),
        .server_time = fd(5, .{ .scalar = .fixed32 }),
        .challenge = fd(6, .{ .scalar = .fixed64 }),
        .seconds_until_shutdown = fd(7, .{ .scalar = .uint32 }),
        .client_cookie = fd(8, .{ .scalar = .fixed32 }),
        .recv_tos = fd(16, .{ .scalar = .uint32 }),
        .echo_sent_tos = fd(17, .{ .scalar = .uint32 }),
        .sent_tos = fd(18, .{ .scalar = .uint32 }),
        .echo_request_reply_tos = fd(19, .{ .scalar = .uint32 }),
        .scoring_penalty_relay_cluster = fd(9, .{ .scalar = .uint32 }),
        .flags = fd(12, .{ .scalar = .uint32 }),
        .route_exceptions = fd(10, .{ .repeated = .submessage }),
        .alt_addresses = fd(13, .{ .repeated = .submessage }),
        .dummy_pad = fd(99, .{ .scalar = .bytes }),
        .dummy_varint = fd(100, .{ .scalar = .uint64 }),
    };

    pub const Flags = enum(i32) {
        FLAG_MAYBE_MORE_DATA_CENTERS = 1,
        FLAG_MAYBE_MORE_ALT_ADDRESSES = 2,
        _,
    };

    pub const RouteException = struct {
        data_center_id: ?u32 = null,
        flags: ?u32 = null,
        penalty: ?u32 = null,

        pub const _desc_table = .{
            .data_center_id = fd(1, .{ .scalar = .fixed32 }),
            .flags = fd(2, .{ .scalar = .uint32 }),
            .penalty = fd(3, .{ .scalar = .uint32 }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const AltAddress = struct {
        ipv4: ?u32 = null,
        port: ?u32 = null,
        penalty: ?u32 = null,
        protocol: ?CMsgSteamDatagramRouterPingReply.AltAddress.Protocol = .DefaultProtocol,
        id: ?[]const u8 = null,

        pub const _desc_table = .{
            .ipv4 = fd(1, .{ .scalar = .fixed32 }),
            .port = fd(2, .{ .scalar = .uint32 }),
            .penalty = fd(3, .{ .scalar = .uint32 }),
            .protocol = fd(4, .@"enum"),
            .id = fd(5, .{ .scalar = .string }),
        };

        pub const Protocol = enum(i32) {
            DefaultProtocol = 0,
            _,
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramGameserverPingRequestBody = struct {
    relay_popid: ?u32 = null,
    your_public_ip: ?CMsgSteamNetworkingIPAddress = null,
    your_public_port: ?u32 = null,
    relay_unix_time: ?u64 = null,
    routing_secret: ?u64 = null,
    my_ips: std.ArrayListUnmanaged(CMsgSteamNetworkingIPAddress) = .empty,
    echo: ?[]const u8 = null,

    pub const _desc_table = .{
        .relay_popid = fd(1, .{ .scalar = .fixed32 }),
        .your_public_ip = fd(2, .submessage),
        .your_public_port = fd(3, .{ .scalar = .uint32 }),
        .relay_unix_time = fd(4, .{ .scalar = .uint64 }),
        .routing_secret = fd(5, .{ .scalar = .fixed64 }),
        .my_ips = fd(6, .{ .repeated = .submessage }),
        .echo = fd(8, .{ .scalar = .bytes }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramGameserverPingRequestEnvelope = struct {
    cert: ?CMsgSteamDatagramCertificateSigned = null,
    signed_data: ?[]const u8 = null,
    signature: ?[]const u8 = null,
    legacy_your_public_ip: ?u32 = null,
    legacy_your_public_port: ?u32 = null,
    legacy_relay_unix_time: ?u32 = null,
    legacy_challenge: ?u64 = null,
    legacy_router_timestamp: ?u32 = null,
    dummy_pad: ?[]const u8 = null,

    pub const _desc_table = .{
        .cert = fd(6, .submessage),
        .signed_data = fd(7, .{ .scalar = .bytes }),
        .signature = fd(8, .{ .scalar = .bytes }),
        .legacy_your_public_ip = fd(1, .{ .scalar = .fixed32 }),
        .legacy_your_public_port = fd(5, .{ .scalar = .fixed32 }),
        .legacy_relay_unix_time = fd(2, .{ .scalar = .fixed32 }),
        .legacy_challenge = fd(3, .{ .scalar = .fixed64 }),
        .legacy_router_timestamp = fd(4, .{ .scalar = .fixed32 }),
        .dummy_pad = fd(1023, .{ .scalar = .bytes }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramGameserverPingReplyData = struct {
    echo_relay_unix_time: ?u32 = null,
    echo: ?[]const u8 = null,
    legacy_challenge: ?u64 = null,
    legacy_router_timestamp: ?u32 = null,
    data_center_id: ?u32 = null,
    appid: ?u32 = null,
    protocol_version: ?u32 = null,
    build: ?[]const u8 = null,
    network_config_version: ?u64 = null,
    my_unix_time: ?u32 = null,
    routing_blob: ?[]const u8 = null,

    pub const _desc_table = .{
        .echo_relay_unix_time = fd(2, .{ .scalar = .fixed32 }),
        .echo = fd(8, .{ .scalar = .bytes }),
        .legacy_challenge = fd(3, .{ .scalar = .fixed64 }),
        .legacy_router_timestamp = fd(4, .{ .scalar = .fixed32 }),
        .data_center_id = fd(5, .{ .scalar = .fixed32 }),
        .appid = fd(6, .{ .scalar = .uint32 }),
        .protocol_version = fd(7, .{ .scalar = .uint32 }),
        .build = fd(9, .{ .scalar = .string }),
        .network_config_version = fd(10, .{ .scalar = .uint64 }),
        .my_unix_time = fd(11, .{ .scalar = .fixed32 }),
        .routing_blob = fd(12, .{ .scalar = .bytes }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramNoSessionRelayToClient = struct {
    connection_id: ?u32 = null,
    your_public_ip: ?u32 = null,
    your_public_port: ?u32 = null,
    server_time: ?u32 = null,
    challenge: ?u64 = null,
    seconds_until_shutdown: ?u32 = null,

    pub const _desc_table = .{
        .connection_id = fd(7, .{ .scalar = .fixed32 }),
        .your_public_ip = fd(2, .{ .scalar = .fixed32 }),
        .your_public_port = fd(6, .{ .scalar = .fixed32 }),
        .server_time = fd(3, .{ .scalar = .fixed32 }),
        .challenge = fd(4, .{ .scalar = .fixed64 }),
        .seconds_until_shutdown = fd(5, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramNoSessionRelayToPeer = struct {
    legacy_relay_session_id: ?u32 = null,
    from_relay_session_id: ?u32 = null,
    from_connection_id: ?u32 = null,
    kludge_pad: ?u64 = null,

    pub const _desc_table = .{
        .legacy_relay_session_id = fd(1, .{ .scalar = .uint32 }),
        .from_relay_session_id = fd(2, .{ .scalar = .fixed32 }),
        .from_connection_id = fd(7, .{ .scalar = .fixed32 }),
        .kludge_pad = fd(99, .{ .scalar = .fixed64 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgTOSTreatment = struct {
    l4s_detect: ?[]const u8 = null,
    up_ecn1: ?[]const u8 = null,
    down_dscp45: ?[]const u8 = null,

    pub const _desc_table = .{
        .l4s_detect = fd(1, .{ .scalar = .string }),
        .up_ecn1 = fd(2, .{ .scalar = .string }),
        .down_dscp45 = fd(3, .{ .scalar = .string }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramClientPingSampleRequest = struct {
    connection_id: ?u32 = null,

    pub const _desc_table = .{
        .connection_id = fd(1, .{ .scalar = .fixed32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramClientPingSampleReply = struct {
    connection_id: ?u32 = null,
    relay_override_active: ?bool = null,
    tos: ?CMsgTOSTreatment = null,
    pops: std.ArrayListUnmanaged(CMsgSteamDatagramClientPingSampleReply.POP) = .empty,
    legacy_data_centers: std.ArrayListUnmanaged(CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter) = .empty,

    pub const _desc_table = .{
        .connection_id = fd(1, .{ .scalar = .fixed32 }),
        .relay_override_active = fd(5, .{ .scalar = .bool }),
        .tos = fd(6, .submessage),
        .pops = fd(2, .{ .repeated = .submessage }),
        .legacy_data_centers = fd(3, .{ .repeated = .submessage }),
    };

    pub const POP = struct {
        pop_id: ?u32 = null,
        default_front_ping_ms: ?u32 = null,
        cluster_penalty: ?u32 = null,
        alt_addresses: std.ArrayListUnmanaged(CMsgSteamDatagramClientPingSampleReply.POP.AltAddress) = .empty,
        default_e2e_ping_ms: ?u32 = null,
        default_e2e_score: ?u32 = null,
        p2p_via_peer_relay_pop_id: ?u32 = null,
        best_dc_ping_ms: ?u32 = null,
        best_dc_score: ?u32 = null,
        best_dc_via_relay_pop_id: ?u32 = null,
        default_dc_ping_ms: ?u32 = null,
        default_dc_score: ?u32 = null,
        default_dc_via_relay_pop_id: ?u32 = null,
        test_dc_ping_ms: ?u32 = null,
        test_dc_score: ?u32 = null,
        test_dc_via_relay_pop_id: ?u32 = null,

        pub const _desc_table = .{
            .pop_id = fd(1, .{ .scalar = .fixed32 }),
            .default_front_ping_ms = fd(2, .{ .scalar = .uint32 }),
            .cluster_penalty = fd(4, .{ .scalar = .uint32 }),
            .alt_addresses = fd(7, .{ .repeated = .submessage }),
            .default_e2e_ping_ms = fd(3, .{ .scalar = .uint32 }),
            .default_e2e_score = fd(5, .{ .scalar = .uint32 }),
            .p2p_via_peer_relay_pop_id = fd(6, .{ .scalar = .fixed32 }),
            .best_dc_ping_ms = fd(9, .{ .scalar = .uint32 }),
            .best_dc_score = fd(10, .{ .scalar = .uint32 }),
            .best_dc_via_relay_pop_id = fd(11, .{ .scalar = .fixed32 }),
            .default_dc_ping_ms = fd(12, .{ .scalar = .uint32 }),
            .default_dc_score = fd(13, .{ .scalar = .uint32 }),
            .default_dc_via_relay_pop_id = fd(14, .{ .scalar = .fixed32 }),
            .test_dc_ping_ms = fd(15, .{ .scalar = .uint32 }),
            .test_dc_score = fd(16, .{ .scalar = .uint32 }),
            .test_dc_via_relay_pop_id = fd(17, .{ .scalar = .fixed32 }),
        };

        pub const AltAddress = struct {
            id: ?[]const u8 = null,
            front_ping_ms: ?u32 = null,
            penalty: ?u32 = null,

            pub const _desc_table = .{
                .id = fd(1, .{ .scalar = .string }),
                .front_ping_ms = fd(2, .{ .scalar = .uint32 }),
                .penalty = fd(3, .{ .scalar = .uint32 }),
            };

            /// Encodes the message to the writer
            /// The allocator is used to generate submessages internally.
            /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
            pub fn encode(
                self: @This(),
                writer: *std.Io.Writer,
                allocator: std.mem.Allocator,
            ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
                return protobuf.encode(writer, allocator, self);
            }

            /// Decodes the message from the bytes read from the reader.
            pub fn decode(
                reader: *std.Io.Reader,
                allocator: std.mem.Allocator,
            ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
                return protobuf.decode(@This(), reader, allocator);
            }

            /// Deinitializes and frees the memory associated with the message.
            pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
                return protobuf.deinit(allocator, self);
            }

            /// Duplicates the message.
            pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
                return protobuf.dupe(@This(), self, allocator);
            }

            /// Decodes the message from the JSON string.
            pub fn jsonDecode(
                input: []const u8,
                options: std.json.ParseOptions,
                allocator: std.mem.Allocator,
            ) !std.json.Parsed(@This()) {
                return protobuf.json.decode(@This(), input, options, allocator);
            }

            /// Encodes the message to a JSON string.
            pub fn jsonEncode(
                self: @This(),
                options: std.json.Stringify.Options,
                allocator: std.mem.Allocator,
            ) ![]const u8 {
                return protobuf.json.encode(self, options, allocator);
            }

            /// This method is used by std.json
            /// internally for deserialization. DO NOT RENAME!
            pub fn jsonParse(
                allocator: std.mem.Allocator,
                source: anytype,
                options: std.json.ParseOptions,
            ) !@This() {
                return protobuf.json.parse(@This(), allocator, source, options);
            }

            /// This method is used by std.json
            /// internally for serialization. DO NOT RENAME!
            pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
                return protobuf.json.stringify(@This(), self, jws);
            }
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const LegacyDataCenter = struct {
        data_center_id: ?u32 = null,
        best_dc_via_relay_pop_id: ?u32 = null,
        best_dc_ping_ms: ?u32 = null,

        pub const _desc_table = .{
            .data_center_id = fd(1, .{ .scalar = .fixed32 }),
            .best_dc_via_relay_pop_id = fd(2, .{ .scalar = .fixed32 }),
            .best_dc_ping_ms = fd(3, .{ .scalar = .uint32 }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramClientSwitchedPrimary = struct {
    connection_id: ?u32 = null,
    from_ip: ?u32 = null,
    from_port: ?u32 = null,
    from_router_cluster: ?u32 = null,
    from_active_time: ?u32 = null,
    from_active_packets_recv: ?u32 = null,
    from_dropped_reason: ?[]const u8 = null,
    gap_ms: ?u32 = null,
    from_quality_now: ?CMsgSteamDatagramClientSwitchedPrimary.RouterQuality = null,
    to_quality_now: ?CMsgSteamDatagramClientSwitchedPrimary.RouterQuality = null,
    from_quality_then: ?CMsgSteamDatagramClientSwitchedPrimary.RouterQuality = null,
    to_quality_then: ?CMsgSteamDatagramClientSwitchedPrimary.RouterQuality = null,

    pub const _desc_table = .{
        .connection_id = fd(1, .{ .scalar = .fixed32 }),
        .from_ip = fd(2, .{ .scalar = .fixed32 }),
        .from_port = fd(3, .{ .scalar = .uint32 }),
        .from_router_cluster = fd(4, .{ .scalar = .fixed32 }),
        .from_active_time = fd(5, .{ .scalar = .uint32 }),
        .from_active_packets_recv = fd(6, .{ .scalar = .uint32 }),
        .from_dropped_reason = fd(7, .{ .scalar = .string }),
        .gap_ms = fd(8, .{ .scalar = .uint32 }),
        .from_quality_now = fd(9, .submessage),
        .to_quality_now = fd(10, .submessage),
        .from_quality_then = fd(11, .submessage),
        .to_quality_then = fd(12, .submessage),
    };

    pub const RouterQuality = struct {
        score: ?u32 = null,
        front_ping: ?u32 = null,
        back_ping: ?u32 = null,
        seconds_until_down: ?u32 = null,

        pub const _desc_table = .{
            .score = fd(1, .{ .scalar = .uint32 }),
            .front_ping = fd(2, .{ .scalar = .uint32 }),
            .back_ping = fd(3, .{ .scalar = .uint32 }),
            .seconds_until_down = fd(4, .{ .scalar = .uint32 }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramConnectRequest = struct {
    connection_id: ?u32 = null,
    my_timestamp: ?u64 = null,
    ping_est_ms: ?u32 = null,
    virtual_port: ?u32 = null,
    gameserver_relay_session_id: ?u32 = null,
    crypt: ?CMsgSteamDatagramSessionCryptInfoSigned = null,
    cert: ?CMsgSteamDatagramCertificateSigned = null,
    routing_secret: ?u64 = null,
    legacy_client_steam_id: ?u64 = null,

    pub const _desc_table = .{
        .connection_id = fd(1, .{ .scalar = .fixed32 }),
        .my_timestamp = fd(4, .{ .scalar = .fixed64 }),
        .ping_est_ms = fd(5, .{ .scalar = .uint32 }),
        .virtual_port = fd(9, .{ .scalar = .uint32 }),
        .gameserver_relay_session_id = fd(2, .{ .scalar = .uint32 }),
        .crypt = fd(6, .submessage),
        .cert = fd(7, .submessage),
        .routing_secret = fd(10, .{ .scalar = .fixed64 }),
        .legacy_client_steam_id = fd(3, .{ .scalar = .fixed64 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramConnectOK = struct {
    client_connection_id: ?u32 = null,
    server_connection_id: ?u32 = null,
    your_timestamp: ?u64 = null,
    delay_time_usec: ?u32 = null,
    gameserver_relay_session_id: ?u32 = null,
    crypt: ?CMsgSteamDatagramSessionCryptInfoSigned = null,
    cert: ?CMsgSteamDatagramCertificateSigned = null,

    pub const _desc_table = .{
        .client_connection_id = fd(1, .{ .scalar = .fixed32 }),
        .server_connection_id = fd(7, .{ .scalar = .fixed32 }),
        .your_timestamp = fd(3, .{ .scalar = .fixed64 }),
        .delay_time_usec = fd(4, .{ .scalar = .uint32 }),
        .gameserver_relay_session_id = fd(2, .{ .scalar = .uint32 }),
        .crypt = fd(5, .submessage),
        .cert = fd(6, .submessage),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamNetworkingP2PSDRRoutingSummary = struct {
    initial_ping: ?u32 = null,
    initial_ping_front_local: ?u32 = null,
    initial_ping_front_remote: ?u32 = null,
    initial_score: ?u32 = null,
    initial_pop_local: ?u32 = null,
    initial_pop_remote: ?u32 = null,
    best_ping: ?u32 = null,
    best_ping_front_local: ?u32 = null,
    best_ping_front_remote: ?u32 = null,
    best_score: ?u32 = null,
    best_pop_local: ?u32 = null,
    best_pop_remote: ?u32 = null,
    best_time: ?u32 = null,
    negotiation_ms: ?u32 = null,
    selected_seconds: ?u32 = null,

    pub const _desc_table = .{
        .initial_ping = fd(1, .{ .scalar = .uint32 }),
        .initial_ping_front_local = fd(2, .{ .scalar = .uint32 }),
        .initial_ping_front_remote = fd(3, .{ .scalar = .uint32 }),
        .initial_score = fd(4, .{ .scalar = .uint32 }),
        .initial_pop_local = fd(5, .{ .scalar = .fixed32 }),
        .initial_pop_remote = fd(6, .{ .scalar = .fixed32 }),
        .best_ping = fd(11, .{ .scalar = .uint32 }),
        .best_ping_front_local = fd(12, .{ .scalar = .uint32 }),
        .best_ping_front_remote = fd(13, .{ .scalar = .uint32 }),
        .best_score = fd(14, .{ .scalar = .uint32 }),
        .best_pop_local = fd(15, .{ .scalar = .fixed32 }),
        .best_pop_remote = fd(16, .{ .scalar = .fixed32 }),
        .best_time = fd(17, .{ .scalar = .uint32 }),
        .negotiation_ms = fd(7, .{ .scalar = .uint32 }),
        .selected_seconds = fd(8, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramP2PRoutingSummary = struct {
    ice: ?CMsgSteamNetworkingICESessionSummary = null,
    sdr: ?CMsgSteamNetworkingP2PSDRRoutingSummary = null,

    pub const _desc_table = .{
        .ice = fd(2, .submessage),
        .sdr = fd(3, .submessage),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramConnectionClosed = struct {
    to_connection_id: ?u32 = null,
    from_connection_id: ?u32 = null,
    from_identity_string: ?[]const u8 = null,
    legacy_from_identity_binary: ?CMsgSteamNetworkingIdentityLegacyBinary = null,
    legacy_from_steam_id: ?u64 = null,
    legacy_gameserver_relay_session_id: ?u32 = null,
    to_relay_session_id: ?u32 = null,
    from_relay_session_id: ?u32 = null,
    forward_target_relay_routing_token: ?[]const u8 = null,
    forward_target_revision: ?u32 = null,
    relay_mode: ?CMsgSteamDatagramConnectionClosed.ERelayMode = .None,
    debug: ?[]const u8 = null,
    reason_code: ?u32 = null,
    routing_secret: ?u64 = null,
    not_primary_session: ?bool = null,
    not_primary_transport: ?bool = null,
    relay_override_active: ?bool = null,
    quality_relay: ?CMsgSteamDatagramConnectionQuality = null,
    quality_e2e: ?CMsgSteamDatagramConnectionQuality = null,
    p2p_routing_summary: ?CMsgSteamDatagramP2PRoutingSummary = null,

    pub const _desc_table = .{
        .to_connection_id = fd(7, .{ .scalar = .fixed32 }),
        .from_connection_id = fd(8, .{ .scalar = .fixed32 }),
        .from_identity_string = fd(15, .{ .scalar = .string }),
        .legacy_from_identity_binary = fd(13, .submessage),
        .legacy_from_steam_id = fd(3, .{ .scalar = .fixed64 }),
        .legacy_gameserver_relay_session_id = fd(2, .{ .scalar = .uint32 }),
        .to_relay_session_id = fd(9, .{ .scalar = .fixed32 }),
        .from_relay_session_id = fd(10, .{ .scalar = .fixed32 }),
        .forward_target_relay_routing_token = fd(11, .{ .scalar = .bytes }),
        .forward_target_revision = fd(12, .{ .scalar = .uint32 }),
        .relay_mode = fd(4, .@"enum"),
        .debug = fd(5, .{ .scalar = .string }),
        .reason_code = fd(6, .{ .scalar = .uint32 }),
        .routing_secret = fd(14, .{ .scalar = .fixed64 }),
        .not_primary_session = fd(16, .{ .scalar = .bool }),
        .not_primary_transport = fd(19, .{ .scalar = .bool }),
        .relay_override_active = fd(22, .{ .scalar = .bool }),
        .quality_relay = fd(17, .submessage),
        .quality_e2e = fd(18, .submessage),
        .p2p_routing_summary = fd(21, .submessage),
    };

    pub const ERelayMode = enum(i32) {
        None = 0,
        EndToEnd = 1,
        ClosedByPeer = 2,
        _,
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramNoConnection = struct {
    to_connection_id: ?u32 = null,
    from_connection_id: ?u32 = null,
    legacy_gameserver_relay_session_id: ?u32 = null,
    to_relay_session_id: ?u32 = null,
    from_relay_session_id: ?u32 = null,
    from_identity_string: ?[]const u8 = null,
    legacy_from_steam_id: ?u64 = null,
    end_to_end: ?bool = null,
    not_primary_session: ?bool = null,
    not_primary_transport: ?bool = null,
    relay_override_active: ?bool = null,
    quality_relay: ?CMsgSteamDatagramConnectionQuality = null,
    quality_e2e: ?CMsgSteamDatagramConnectionQuality = null,
    p2p_routing_summary: ?CMsgSteamDatagramP2PRoutingSummary = null,
    routing_secret: ?u64 = null,
    dummy_pad: ?u32 = null,

    pub const _desc_table = .{
        .to_connection_id = fd(5, .{ .scalar = .fixed32 }),
        .from_connection_id = fd(6, .{ .scalar = .fixed32 }),
        .legacy_gameserver_relay_session_id = fd(2, .{ .scalar = .uint32 }),
        .to_relay_session_id = fd(9, .{ .scalar = .fixed32 }),
        .from_relay_session_id = fd(10, .{ .scalar = .fixed32 }),
        .from_identity_string = fd(7, .{ .scalar = .string }),
        .legacy_from_steam_id = fd(3, .{ .scalar = .fixed64 }),
        .end_to_end = fd(4, .{ .scalar = .bool }),
        .not_primary_session = fd(12, .{ .scalar = .bool }),
        .not_primary_transport = fd(15, .{ .scalar = .bool }),
        .relay_override_active = fd(17, .{ .scalar = .bool }),
        .quality_relay = fd(13, .submessage),
        .quality_e2e = fd(14, .submessage),
        .p2p_routing_summary = fd(16, .submessage),
        .routing_secret = fd(11, .{ .scalar = .fixed64 }),
        .dummy_pad = fd(1023, .{ .scalar = .fixed32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramGameserverSessionRequest = struct {
    ticket: ?[]const u8 = null,
    challenge_time: ?u32 = null,
    challenge: ?u64 = null,
    client_connection_id: ?u32 = null,
    server_connection_id: ?u32 = null,
    network_config_version: ?u64 = null,
    protocol_version: ?u32 = null,
    platform: ?[]const u8 = null,
    build: ?[]const u8 = null,
    dev_gameserver_identity: ?[]const u8 = null,
    dev_client_cert: ?CMsgSteamDatagramCertificateSigned = null,

    pub const _desc_table = .{
        .ticket = fd(1, .{ .scalar = .bytes }),
        .challenge_time = fd(3, .{ .scalar = .fixed32 }),
        .challenge = fd(4, .{ .scalar = .fixed64 }),
        .client_connection_id = fd(5, .{ .scalar = .fixed32 }),
        .server_connection_id = fd(8, .{ .scalar = .fixed32 }),
        .network_config_version = fd(6, .{ .scalar = .uint64 }),
        .protocol_version = fd(7, .{ .scalar = .uint32 }),
        .platform = fd(9, .{ .scalar = .string }),
        .build = fd(10, .{ .scalar = .string }),
        .dev_gameserver_identity = fd(100, .{ .scalar = .string }),
        .dev_client_cert = fd(101, .submessage),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramGameserverSessionEstablished = struct {
    connection_id: ?u32 = null,
    gameserver_identity_string: ?[]const u8 = null,
    seconds_until_shutdown: ?u32 = null,
    seq_num_r2c: ?u32 = null,
    dummy_legacy_identity_binary: ?[]const u8 = null,
    legacy_gameserver_steamid: ?u64 = null,

    pub const _desc_table = .{
        .connection_id = fd(1, .{ .scalar = .fixed32 }),
        .gameserver_identity_string = fd(2, .{ .scalar = .string }),
        .seconds_until_shutdown = fd(4, .{ .scalar = .uint32 }),
        .seq_num_r2c = fd(6, .{ .scalar = .uint32 }),
        .dummy_legacy_identity_binary = fd(7, .{ .scalar = .bytes }),
        .legacy_gameserver_steamid = fd(3, .{ .scalar = .fixed64 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramConnectionStatsClientToRouter = struct {
    quality_relay: ?CMsgSteamDatagramConnectionQuality = null,
    quality_e2e: ?CMsgSteamDatagramConnectionQuality = null,
    ack_relay: std.ArrayListUnmanaged(u32) = .empty,
    legacy_ack_e2e: std.ArrayListUnmanaged(u32) = .empty,
    flags: ?u32 = null,
    client_connection_id: ?u32 = null,
    seq_num_c2r: ?u32 = null,
    seq_num_e2e: ?u32 = null,

    pub const _desc_table = .{
        .quality_relay = fd(1, .submessage),
        .quality_e2e = fd(2, .submessage),
        .ack_relay = fd(4, .{ .repeated = .{ .scalar = .fixed32 } }),
        .legacy_ack_e2e = fd(5, .{ .repeated = .{ .scalar = .fixed32 } }),
        .flags = fd(6, .{ .scalar = .uint32 }),
        .client_connection_id = fd(8, .{ .scalar = .fixed32 }),
        .seq_num_c2r = fd(9, .{ .scalar = .uint32 }),
        .seq_num_e2e = fd(10, .{ .scalar = .uint32 }),
    };

    pub const Flags = enum(i32) {
        ACK_REQUEST_RELAY = 1,
        ACK_REQUEST_E2E = 2,
        ACK_REQUEST_IMMEDIATE = 4,
        NOT_PRIMARY_SESSION = 8,
        CLIENT_RELAY_OVERRIDE = 32,
        _,
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramConnectionStatsRouterToClient = struct {
    quality_relay: ?CMsgSteamDatagramConnectionQuality = null,
    quality_e2e: ?CMsgSteamDatagramConnectionQuality = null,
    seconds_until_shutdown: ?u32 = null,
    migrate_request_ip: ?u32 = null,
    migrate_request_port: ?u32 = null,
    scoring_penalty_relay_cluster: ?u32 = null,
    ack_relay: std.ArrayListUnmanaged(u32) = .empty,
    legacy_ack_e2e: std.ArrayListUnmanaged(u32) = .empty,
    flags: ?u32 = null,
    client_connection_id: ?u32 = null,
    seq_num_r2c: ?u32 = null,
    seq_num_e2e: ?u32 = null,

    pub const _desc_table = .{
        .quality_relay = fd(1, .submessage),
        .quality_e2e = fd(2, .submessage),
        .seconds_until_shutdown = fd(6, .{ .scalar = .uint32 }),
        .migrate_request_ip = fd(10, .{ .scalar = .fixed32 }),
        .migrate_request_port = fd(11, .{ .scalar = .uint32 }),
        .scoring_penalty_relay_cluster = fd(12, .{ .scalar = .uint32 }),
        .ack_relay = fd(13, .{ .repeated = .{ .scalar = .fixed32 } }),
        .legacy_ack_e2e = fd(14, .{ .repeated = .{ .scalar = .fixed32 } }),
        .flags = fd(15, .{ .scalar = .uint32 }),
        .client_connection_id = fd(7, .{ .scalar = .fixed32 }),
        .seq_num_r2c = fd(8, .{ .scalar = .uint32 }),
        .seq_num_e2e = fd(9, .{ .scalar = .uint32 }),
    };

    pub const Flags = enum(i32) {
        ACK_REQUEST_RELAY = 1,
        ACK_REQUEST_E2E = 2,
        ACK_REQUEST_IMMEDIATE = 4,
        _,
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramConnectionStatsRouterToServer = struct {
    quality_relay: ?CMsgSteamDatagramConnectionQuality = null,
    quality_e2e: ?CMsgSteamDatagramConnectionQuality = null,
    ack_relay: std.ArrayListUnmanaged(u32) = .empty,
    legacy_ack_e2e: std.ArrayListUnmanaged(u32) = .empty,
    flags: ?u32 = null,
    seq_num_r2s: ?u32 = null,
    seq_num_e2e: ?u32 = null,
    client_identity_string: ?[]const u8 = null,
    legacy_client_steam_id: ?u64 = null,
    relay_session_id: ?u32 = null,
    client_connection_id: ?u32 = null,
    server_connection_id: ?u32 = null,
    routing_secret: ?u64 = null,

    pub const _desc_table = .{
        .quality_relay = fd(1, .submessage),
        .quality_e2e = fd(2, .submessage),
        .ack_relay = fd(10, .{ .repeated = .{ .scalar = .fixed32 } }),
        .legacy_ack_e2e = fd(11, .{ .repeated = .{ .scalar = .fixed32 } }),
        .flags = fd(12, .{ .scalar = .uint32 }),
        .seq_num_r2s = fd(5, .{ .scalar = .uint32 }),
        .seq_num_e2e = fd(6, .{ .scalar = .uint32 }),
        .client_identity_string = fd(15, .{ .scalar = .string }),
        .legacy_client_steam_id = fd(7, .{ .scalar = .fixed64 }),
        .relay_session_id = fd(8, .{ .scalar = .uint32 }),
        .client_connection_id = fd(9, .{ .scalar = .fixed32 }),
        .server_connection_id = fd(13, .{ .scalar = .fixed32 }),
        .routing_secret = fd(14, .{ .scalar = .fixed64 }),
    };

    pub const Flags = enum(i32) {
        ACK_REQUEST_RELAY = 1,
        ACK_REQUEST_E2E = 2,
        ACK_REQUEST_IMMEDIATE = 4,
        _,
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramConnectionStatsServerToRouter = struct {
    quality_relay: ?CMsgSteamDatagramConnectionQuality = null,
    quality_e2e: ?CMsgSteamDatagramConnectionQuality = null,
    ack_relay: std.ArrayListUnmanaged(u32) = .empty,
    legacy_ack_e2e: std.ArrayListUnmanaged(u32) = .empty,
    flags: ?u32 = null,
    seq_num_s2r: ?u32 = null,
    seq_num_e2e: ?u32 = null,
    relay_session_id: ?u32 = null,
    client_connection_id: ?u32 = null,
    server_connection_id: ?u32 = null,

    pub const _desc_table = .{
        .quality_relay = fd(1, .submessage),
        .quality_e2e = fd(2, .submessage),
        .ack_relay = fd(8, .{ .repeated = .{ .scalar = .fixed32 } }),
        .legacy_ack_e2e = fd(9, .{ .repeated = .{ .scalar = .fixed32 } }),
        .flags = fd(10, .{ .scalar = .uint32 }),
        .seq_num_s2r = fd(3, .{ .scalar = .uint32 }),
        .seq_num_e2e = fd(4, .{ .scalar = .uint32 }),
        .relay_session_id = fd(6, .{ .scalar = .uint32 }),
        .client_connection_id = fd(7, .{ .scalar = .fixed32 }),
        .server_connection_id = fd(11, .{ .scalar = .fixed32 }),
    };

    pub const Flags = enum(i32) {
        ACK_REQUEST_RELAY = 1,
        ACK_REQUEST_E2E = 2,
        ACK_REQUEST_IMMEDIATE = 4,
        _,
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramP2PSessionRequestBody = struct {
    challenge_time: ?u32 = null,
    challenge: ?u64 = null,
    client_connection_id: ?u32 = null,
    legacy_peer_steam_id: ?u64 = null,
    peer_identity_string: ?[]const u8 = null,
    peer_connection_id: ?u32 = null,
    encrypted_data: ?[]const u8 = null,
    encryption_your_public_key_lead_byte: ?u32 = null,
    encryption_my_ephemeral_public_key: ?[]const u8 = null,
    protocol_version: ?u32 = null,
    network_config_version: ?u64 = null,
    platform: ?[]const u8 = null,
    build: ?[]const u8 = null,

    pub const _desc_table = .{
        .challenge_time = fd(1, .{ .scalar = .fixed32 }),
        .challenge = fd(2, .{ .scalar = .fixed64 }),
        .client_connection_id = fd(3, .{ .scalar = .fixed32 }),
        .legacy_peer_steam_id = fd(4, .{ .scalar = .fixed64 }),
        .peer_identity_string = fd(11, .{ .scalar = .string }),
        .peer_connection_id = fd(5, .{ .scalar = .fixed32 }),
        .encrypted_data = fd(14, .{ .scalar = .bytes }),
        .encryption_your_public_key_lead_byte = fd(15, .{ .scalar = .uint32 }),
        .encryption_my_ephemeral_public_key = fd(16, .{ .scalar = .bytes }),
        .protocol_version = fd(8, .{ .scalar = .uint32 }),
        .network_config_version = fd(9, .{ .scalar = .uint64 }),
        .platform = fd(12, .{ .scalar = .string }),
        .build = fd(13, .{ .scalar = .string }),
    };

    pub const EncryptedData = struct {
        peer_identity_string: ?[]const u8 = null,

        pub const _desc_table = .{
            .peer_identity_string = fd(1, .{ .scalar = .string }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramP2PSessionRequest = struct {
    cert: ?CMsgSteamDatagramCertificateSigned = null,
    body: ?[]const u8 = null,
    signature: ?[]const u8 = null,

    pub const _desc_table = .{
        .cert = fd(1, .submessage),
        .body = fd(2, .{ .scalar = .bytes }),
        .signature = fd(3, .{ .scalar = .bytes }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramP2PSessionEstablished = struct {
    connection_id: ?u32 = null,
    seconds_until_shutdown: ?u32 = null,
    relay_routing_token: ?[]const u8 = null,
    seq_num_r2c: ?u32 = null,

    pub const _desc_table = .{
        .connection_id = fd(1, .{ .scalar = .fixed32 }),
        .seconds_until_shutdown = fd(3, .{ .scalar = .uint32 }),
        .relay_routing_token = fd(4, .{ .scalar = .bytes }),
        .seq_num_r2c = fd(5, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramConnectionStatsP2PClientToRouter = struct {
    quality_relay: ?CMsgSteamDatagramConnectionQuality = null,
    quality_e2e: ?CMsgSteamDatagramConnectionQuality = null,
    p2p_routing_summary: ?CMsgSteamDatagramP2PRoutingSummary = null,
    ack_relay: std.ArrayListUnmanaged(u32) = .empty,
    legacy_ack_e2e: std.ArrayListUnmanaged(u32) = .empty,
    flags: ?u32 = null,
    forward_target_relay_routing_token: ?[]const u8 = null,
    forward_target_revision: ?u32 = null,
    routes: ?[]const u8 = null,
    ack_peer_routes_revision: ?u32 = null,
    connection_id: ?u32 = null,
    seq_num_c2r: ?u32 = null,
    seq_num_e2e: ?u32 = null,

    pub const _desc_table = .{
        .quality_relay = fd(1, .submessage),
        .quality_e2e = fd(2, .submessage),
        .p2p_routing_summary = fd(14, .submessage),
        .ack_relay = fd(3, .{ .repeated = .{ .scalar = .fixed32 } }),
        .legacy_ack_e2e = fd(4, .{ .repeated = .{ .scalar = .fixed32 } }),
        .flags = fd(5, .{ .scalar = .uint32 }),
        .forward_target_relay_routing_token = fd(6, .{ .scalar = .bytes }),
        .forward_target_revision = fd(7, .{ .scalar = .uint32 }),
        .routes = fd(8, .{ .scalar = .bytes }),
        .ack_peer_routes_revision = fd(9, .{ .scalar = .uint32 }),
        .connection_id = fd(10, .{ .scalar = .fixed32 }),
        .seq_num_c2r = fd(11, .{ .scalar = .uint32 }),
        .seq_num_e2e = fd(12, .{ .scalar = .uint32 }),
    };

    pub const Flags = enum(i32) {
        ACK_REQUEST_RELAY = 1,
        ACK_REQUEST_E2E = 2,
        ACK_REQUEST_IMMEDIATE = 4,
        NOT_PRIMARY_SESSION = 8,
        NOT_PRIMARY_TRANSPORT_E2E = 16,
        CLIENT_RELAY_OVERRIDE = 32,
        _,
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramConnectionStatsP2PRouterToClient = struct {
    quality_relay: ?CMsgSteamDatagramConnectionQuality = null,
    quality_e2e: ?CMsgSteamDatagramConnectionQuality = null,
    seconds_until_shutdown: ?u32 = null,
    migrate_request_ip: ?u32 = null,
    migrate_request_port: ?u32 = null,
    scoring_penalty_relay_cluster: ?u32 = null,
    ack_relay: std.ArrayListUnmanaged(u32) = .empty,
    legacy_ack_e2e: std.ArrayListUnmanaged(u32) = .empty,
    flags: ?u32 = null,
    ack_forward_target_revision: ?u32 = null,
    routes: ?[]const u8 = null,
    ack_peer_routes_revision: ?u32 = null,
    connection_id: ?u32 = null,
    seq_num_r2c: ?u32 = null,
    seq_num_e2e: ?u32 = null,

    pub const _desc_table = .{
        .quality_relay = fd(1, .submessage),
        .quality_e2e = fd(2, .submessage),
        .seconds_until_shutdown = fd(3, .{ .scalar = .uint32 }),
        .migrate_request_ip = fd(4, .{ .scalar = .fixed32 }),
        .migrate_request_port = fd(5, .{ .scalar = .uint32 }),
        .scoring_penalty_relay_cluster = fd(6, .{ .scalar = .uint32 }),
        .ack_relay = fd(7, .{ .repeated = .{ .scalar = .fixed32 } }),
        .legacy_ack_e2e = fd(8, .{ .repeated = .{ .scalar = .fixed32 } }),
        .flags = fd(9, .{ .scalar = .uint32 }),
        .ack_forward_target_revision = fd(10, .{ .scalar = .uint32 }),
        .routes = fd(11, .{ .scalar = .bytes }),
        .ack_peer_routes_revision = fd(12, .{ .scalar = .uint32 }),
        .connection_id = fd(13, .{ .scalar = .fixed32 }),
        .seq_num_r2c = fd(14, .{ .scalar = .uint32 }),
        .seq_num_e2e = fd(15, .{ .scalar = .uint32 }),
    };

    pub const Flags = enum(i32) {
        ACK_REQUEST_RELAY = 1,
        ACK_REQUEST_E2E = 2,
        ACK_REQUEST_IMMEDIATE = 4,
        NOT_PRIMARY_TRANSPORT_E2E = 16,
        _,
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramP2PBadRouteRouterToClient = struct {
    connection_id: ?u32 = null,
    failed_relay_routing_token: ?[]const u8 = null,
    ack_forward_target_revision: ?u32 = null,
    kludge_pad: ?u64 = null,

    pub const _desc_table = .{
        .connection_id = fd(1, .{ .scalar = .fixed32 }),
        .failed_relay_routing_token = fd(2, .{ .scalar = .bytes }),
        .ack_forward_target_revision = fd(3, .{ .scalar = .uint32 }),
        .kludge_pad = fd(99, .{ .scalar = .fixed64 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramP2PRoutes = struct {
    relay_clusters: std.ArrayListUnmanaged(CMsgSteamDatagramP2PRoutes.RelayCluster) = .empty,
    routes: std.ArrayListUnmanaged(CMsgSteamDatagramP2PRoutes.Route) = .empty,
    revision: ?u32 = null,

    pub const _desc_table = .{
        .relay_clusters = fd(1, .{ .repeated = .submessage }),
        .routes = fd(2, .{ .repeated = .submessage }),
        .revision = fd(3, .{ .scalar = .uint32 }),
    };

    pub const RelayCluster = struct {
        pop_id: ?u32 = null,
        ping_ms: ?u32 = null,
        score_penalty: ?u32 = null,
        session_relay_routing_token: ?[]const u8 = null,

        pub const _desc_table = .{
            .pop_id = fd(1, .{ .scalar = .fixed32 }),
            .ping_ms = fd(2, .{ .scalar = .uint32 }),
            .score_penalty = fd(3, .{ .scalar = .uint32 }),
            .session_relay_routing_token = fd(4, .{ .scalar = .bytes }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const Route = struct {
        my_pop_id: ?u32 = null,
        your_pop_id: ?u32 = null,
        legacy_score: ?u32 = null,
        interior_score: ?u32 = null,

        pub const _desc_table = .{
            .my_pop_id = fd(1, .{ .scalar = .fixed32 }),
            .your_pop_id = fd(2, .{ .scalar = .fixed32 }),
            .legacy_score = fd(3, .{ .scalar = .uint32 }),
            .interior_score = fd(4, .{ .scalar = .uint32 }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramSetSecondaryAddressRequest = struct {
    client_main_ip: ?u32 = null,
    client_main_port: ?u32 = null,
    client_connection_id: ?u32 = null,
    client_identity: ?[]const u8 = null,
    request_send_duplication: ?bool = null,
    kludge_pad: ?[]const u8 = null,

    pub const _desc_table = .{
        .client_main_ip = fd(1, .{ .scalar = .fixed32 }),
        .client_main_port = fd(2, .{ .scalar = .fixed32 }),
        .client_connection_id = fd(3, .{ .scalar = .fixed32 }),
        .client_identity = fd(4, .{ .scalar = .string }),
        .request_send_duplication = fd(5, .{ .scalar = .bool }),
        .kludge_pad = fd(99, .{ .scalar = .bytes }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CMsgSteamDatagramSetSecondaryAddressResult = struct {
    success: ?bool = null,
    message: ?[]const u8 = null,

    pub const _desc_table = .{
        .success = fd(1, .{ .scalar = .bool }),
        .message = fd(2, .{ .scalar = .string }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};
